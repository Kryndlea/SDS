---
title: "Clustering and regionalisation"
format:
  html: default
  ipynb: default
jupyter: sds
---

::: {.callout-caution}
This course material is currently under construction and is likely incomplete. The final
version will be released in October 2023.
:::

This session is all about finding groups of similar observations in data using clustering
techniques.

Many questions and topics are complex phenomena that involve several dimensions and are
hard to summarise into a single variable. In statistical terms, we call this family of
problems *multivariate*, as opposed to *univariate* cases where only a single variable is
considered in the analysis. Clustering tackles this kind of questions by reducing their
dimensionality -the number of relevant variables the analyst needs to look at - and
converting it into a more intuitive set of classes that even non-technical audiences can
look at and make sense of. For this reason, it is widely used in applied contexts such as
policymaking or marketing. In addition, since these methods do not require many
preliminary assumptions about the structure of the data, it is a commonly used
exploratory tool, as it can quickly give clues about the shape, form and content of a
dataset.

The basic idea of statistical clustering is to summarise the information contained in
several variables by creating a relatively small number of categories. Each observation
in the dataset is then assigned to one, and only one, category depending on its values
for the variables originally considered in the classification. If done correctly, the
exercise reduces the complexity of a multi-dimensional problem while retaining all the
meaningful information contained in the original dataset. This is because once
classified, the analyst only needs to look at in which category every observation falls
into, instead of considering the multiple values associated with each of the variables
and trying to figure out how to put them together in a coherent sense. When the
clustering is performed on observations that represent areas, the technique is often
called geodemographic analysis.

Although there exist many techniques to statistically group observations in a dataset,
all of them are based on the premise of using a set of attributes to define classes or
categories of observations that are similar *within* each of them, but differ *between*
groups. How similarity within groups and dissimilarity between them is defined and how
the classification algorithm is operationalised is what makes techniques differ and also
what makes each of them particularly well suited for specific problems or types of data.

In the case of analysing spatial data, there is a subset of methods that are of
particular interest for many common cases in Spatial Data Science. These are the
so-called *regionalisation* techniques. Regionalisation methods can take also many forms
and faces but, at their core, they all involve statistical clustering of observations
with the additional constraint that observations need to be geographical neighbors to be
in the same category. Because of this, rather than category, we will use the term *area*
for each observation and *region* for each category, hence regionalization, the
construction of regions from smaller areas.

The Python package you will use for clustering today is called `scikit-learn` and can
be imported as `sklearn`.

```{python}
import geopandas as gpd
import seaborn as sns
from libpysal import graph
from sklearn import cluster
```


## Attribute-based clustering

In this session, you will be working with another dataset you should already
be familiar with - the Scottish Index of Multiple Deprivation. This time, you will focus
only on the area of Glasgow City, prepared for this course.

### Scottish Index of Multiple Deprivation

As always, the table can be read from the site:

```{python}
simd = gpd.read_file("data/glasgow_simd_2020.gpkg")
```

::: {.callout-note collapse="true"}
## Alternative
Instead of reading the file directly off the web, it is possible to download it manually,
store it on your computer, and read it locally. To do that, you can follow these steps:

1. Download the file by right-clicking on
[this link](https://martinfleischmann.net/sds/chapter_07/data/glasgow_simd_2020.gpkg)
and saving the file
2. Place the file in the same folder as the notebook where you intend to read it
3. Replace the code in the cell above with:

```python
simd = gpd.read_file(
    "glasgow_simd_2020.gpkg",
)
```
:::

Inspect the structure of the table:

```{python}
simd.info()
```

Before we jump into exploring the data, one additional step that will come in handy down the line. Not every variable in the table is an attribute that we will want for the clustering. In particular, we are interested in sub-ranks based on individual SIMD domains, so we will only consider those. Hence, let us first manually write them so they are easier to subset:

```{python}
subranks = [
    "IncRankv2",
    "EmpRank",
    "HlthRank",
    "EduRank",
    "GAccRank",
    "CrimeRank",
    "HouseRank"
]
```

You can quickly familiarise yourself with those variables by plotting a few maps like the one below to build your intuition about what is going to happen.
```{python}
simd[["IncRankv2", "geometry"]].explore("IncRankv2", tiles="CartoDB Positron", tooltip=False)
```

You can see a decent degree of spatial variation between different sub-ranks. Even though we only have seven variables, it is very hard to "mentally overlay" all of them to come up with an overall assessment of the nature of each part of Glasgow. For bivariate correlations, a useful tool is the correlation matrix plot, available in `seaborn`:


```{python}
# | fig-cap: pairplot
_ = sns.pairplot(simd[subranks],height=1, plot_kws={"s":1})
```

This is helpful to consider uni and bivariate questions such as: *what is the relationship between the ranks?* *Is health correlated with income?* However, sometimes, this is not enough and we are interested in more sophisticated questions that are truly multivariate and, in these cases, the figure above cannot help us. For example, it is not straightforward to answer questions like: *what are the main characteristics of the South of Glasgow?* *What areas are similar to the core of the city?* *Are the East and West of Glasgow similar in terms of deprivation levels?* For these kinds of multi-dimensional questions -involving multiple variables at the same time- we require a truly multidimensional method like statistical clustering.

### K-Means

A cluster analysis involves the classification of the areas that make up a greographical map into groups or categories of observations that are similar within each other but different between them. The classification is carried out using a statistical clustering algorithm that takes as input a set of attributes and returns the group ("labels" in the terminology) each observation belongs to. Depending on the particular algorithm employed, additional parameters, such as the desired number of clusters employed or more advanced tuning parameters (e.g. bandwith, radius, etc.), also need to be entered as inputs. For our  classification of SIMD in Glasgow, we will start with one of the most popular clustering algorithms: K-means. This technique only requires as input the observation attributes and the final number of groups that we want it to cluster the observations into. In our case, we will use five to begin with as this will allow us to have a closer look into each of them.

Although the underlying algorithm is not trivial, running K-means in Python is streamlined thanks to `scikit-learn`. Similar to the extensive set of available algorithms in the library, its computation is a matter of two lines of code. First, we need to specify the parameters in the `KMeans` method (which is part of `scikit-learn`'s `cluster` submodule). Note that, at this point, we do not even need to pass the data:

```{python}
kmeans5 = cluster.KMeans(n_clusters=5, random_state=42) # <1>
```
1. `n_clusters` specifies the number of clusters you want to get and `random_state` sets the random generator to a known state, ensuring that the result is always the same.

This sets up an object that holds all the parameters required to run the algorithm. To actually run the algorithm on the attributes, we need to call the `fit` method in `kmeans5`:

```{python}
kmeans5.fit(simd[subranks])  # <1>
```
1. `fit()` takes an array of data, therefore pass the columns of `simd` with sub-ranks and run the clustering algorithm on that.

The `kmeans5` object now contains several components that can be useful for an analysis. For now, we will use the labels, which represent the different categories in which we have grouped the data. Remember, in Python, life starts at zero, so the group labels go from zero to four. Labels can be  extracted as follows:

```{python}
kmeans5.labels_
```

Each number represents a different category, so two observations with the same number belong to same group. The labels are returned in the same order as the input attributes were passed in, which means we can append them to the original table of data as an additional column:

```{python}
simd["kmeans_5"] = kmeans5.labels_
simd["kmeans_5"].head()
```

To get a better understanding of the classification we have just performed, it is useful to display the categories created on a map. For this, we will use a unique values choropleth, which will automatically assign a different color to each category:

```{python}
simd[["kmeans_5", 'geometry']].explore("kmeans_5", categorical=True, tiles="CartoDB Positron")
```

The map above represents the geographical distribution of the five categories created by the K-means algorithm. A quick glance shows a strong spatial structure in the distribution of the colours: group 3 (grey) is mostly in central areas and towards the west, group 1 (green) covers peripheries and so on, but not all clusters are equally represented.

### Exploring the nature of the categories

Once we have a sense of where and how the categories are distributed over space, it is also useful to explore them statistically. This will allow us to characterize them, giving us an idea of the kind of observations subsumed into each of them. As a first step, let us find how many observations are in each category. To do that, we will make use of the `groupby` operator introduced before, combined with the function `size`, which returns the number of elements in a subgroup:

```{python}
k5sizes = simd.groupby('kmeans_5').size()
k5sizes
```

The `groupby` operator groups a table (`DataFrame`) using the values in the column provided (`kmeans_5`) and passes them onto the function provided aftwerards, which in this case is `size`. Effectively, what this does is to groupby the observations by the categories created and count how many of them each contains. For a more visual representation of the output, a bar plot is a good alternative:

```{python}
_ = k5sizes.plot.bar()
```

As we suspected from the map, groups vary in sizes, with group 2 having over 200 observations, groups 0, 1 and 4 over 100 and a group 3 having 74 observations.

In order to describe the nature of each category, we can look at the values of each of the attributes we have used to create them in the first place. Remember we used the sub-ranks on many aspects of deprivation to create the classification, so we can begin by checking the average value of each. To do that in Python, we will rely on the `groupby` operator which we will combine it with the function `mean`:

```{python}
k5_means = simd.groupby('kmeans_5')[subranks].mean()  # <1>
k5_means.T  # <2>
```
1. Use `groupby` to calculate mean per each sub-rank.
2. Transpose the table so it is not too wide

When interpreting the values, remember that lower value represents higher deprivation. While the results seem plausible and there are ways of interpreting them, we haven't used any spatial methods.

## Spatially-lagged clustering
- K-Means + lag

```{python}
queen = graph.Graph.build_contiguity(simd)
```

```{python}
queen_row = queen.transform("R")
```

```{python}
for column in subranks:
    simd[column + "_lag"] = queen_row.lag(simd[column])
```

```{python}
simd.info()
```

```{python}
subranks_lag = [column + "_lag" for column in subranks]
subranks_lag
```

```{python}
subranks_spatial = subranks + subranks_lag
subranks_spatial
```

```{python}
kmeans5_lag = cluster.KMeans(n_clusters=5, random_state=42)
```

```{python}
kmeans5_lag.fit(simd[subranks_spatial])
```

```{python}
simd["kmeans_5_lagged"] = kmeans5_lag.labels_
```

```{python}
simd[["kmeans_5_lagged", 'geometry']].explore("kmeans_5_lagged", categorical=True, tiles="CartoDB Positron")
```

## Spatially-constrained clustering (regionalisation)
- Agglomerative - weights constraint

```{python}
agg5 = cluster.AgglomerativeClustering(n_clusters=5, connectivity=queen.sparse)
```

```{python}
agg5.fit(simd[subranks])
```

```{python}
simd["agg_5_lagged"] = agg5.labels_
```

```{python}
simd[["agg_5_lagged", 'geometry']].explore("agg_5_lagged", categorical=True, tiles="CartoDB Positron")
```

```{python}
simd_regions = simd[["agg_5_lagged", "geometry"]].dissolve("agg_5_lagged")
simd_regions
```

```{python}
simd_regions.reset_index().explore("agg_5_lagged", categorical=True, tiles="CartoDB Positron")
```
